#╔════════════════════════════════════════════════════════════════════════════════╗
#║                                                                                ║
#║   helpers.ps1                                                                  ║
#║                                                                                ║
#╟────────────────────────────────────────────────────────────────────────────────╢
#║   Guillaume Plante <codegp@icloud.com>                                         ║
#║   Code licensed under the GNU GPL v3.0. See the LICENSE file for details.      ║
#╚════════════════════════════════════════════════════════════════════════════════╝


function Write-SchedTaskProperties {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $true, Position = 0, HelpMessage = "Name of the scheduled task")]
        [string]$TaskName,

        [Parameter(Mandatory = $true, Position = 1, HelpMessage = "Properties of the scheduled task")]
        [pscustomobject]$TaskProperties
    )

    $registryPath = "HKCU:\Software\arsscriptum\PowerShell.Module.ClientTools\SchedTasks\TasksProperties\{0}" -f $TaskName
    $registryPathTypes = "$registryPath\Types" 

    # Ensure the registry path exists
    if (-not (Test-Path $registryPath)) {
        New-Item -Path $registryPath -Force | Out-Null
    }
    if (-not (Test-Path $registryPathTypes)) {
        New-Item -Path $registryPathTypes -Force | Out-Null
    }

    foreach ($prop in $TaskProperties.PSObject.Properties) {
        $VariableName = "$($prop.Name)"
        $value = $prop.Value
        $type = $value.GetType()
        $VariableValue = ($prop.Value -as $prop.TypeNameOfValue)
        $VariableType = ($prop.Value).GetType()
        $VariableTypeFull = $VariableType.FullName
        $RegValueType = 'String' # Default

        Write-Verbose "$VariableName is a [$($VariableType.Name)] ($VariableTypeFull)"

        $DefaultType = $False

        if (($VariableType -eq [uint32]) -or ($VariableType -eq [int32])) {
            $RegValueType = 'DWord'
        } elseif (($VariableType -eq [bool]) -or ($VariableType -eq [Boolean])) {
            $RegValueType = 'Binary'
        } elseif (($VariableType -eq [decimal]) -or ($VariableType -eq [int64]) -or ($VariableType -eq [uint64])) {
            $RegValueType = 'QWord'
        } elseif ($VariableType -eq [string[]]) {
            $RegValueType = 'MultiString'
        } elseif ($VariableType -eq [string]) {
            $RegValueType = if ($VariableValue -match '[$%]') { 'ExpandString' } else { 'String' }
        } else {
            $DefaultType = $True
            $RegValueType = 'String'
        }

        if ($DefaultType) {
            Write-Verbose "cannot identify $VariableName registry type. default to string"
        } else {
            Write-Verbose "identified $VariableName registry type to $RegValueType"
        }
        Write-Verbose "Property `"$VariableName`" has value $VariableValue as [$VariableType] ($VariableTypeFull). Saved as $RegValueType"
        # Write to registry
        try {
            # registry value type -> $Kind
            #  "String", "ExpandString", "Binary", "DWord", "MultiString", "QWord"
            Write-Verbose "[Write-SchedTaskProperties] New-ItemProperty -Path $registryPath -Name $VariableName -Value $VariableValue -PropertyType $RegValueType"

            New-ItemProperty -Path $registryPath -Name $VariableName -Value $VariableValue -PropertyType $RegValueType -Force | Out-null
            New-ItemProperty -Path $registryPathTypes -Name "$VariableName" -Value "$VariableTypeFull" -PropertyType 'String' -Force | Out-null
        } catch {
            Write-Warning "Failed to register '$property_name': $_"
        }
    }
}


function Read-SchedTaskProperties {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $true, Position = 0, HelpMessage = "Name of the scheduled task")]
        [string]$TaskName
    )

    $registryPath = "HKCU:\Software\arsscriptum\PowerShell.Module.ClientTools\SchedTasks\TasksProperties\{0}" -f $TaskName
    $registryPathTypes = "$registryPath\Types"

    if (-not (Test-Path $registryPath)) {
        throw "Task registry path '$registryPath' does not exist."
    }

    $TaskProperties = [pscustomobject]@{}
    $Key = Get-Item -Path $registryPath -ErrorAction Stop
    $Properties = $Key.Property

    foreach ($property_name in $Properties) {
        try {
            # Read raw string type from Types subkey
            $typeString = (Get-ItemProperty -Path $registryPathTypes -Name $property_name).$property_name
            $property_value = (Get-ItemProperty -Path $registryPath -Name $property_name).$property_name

            # Convert type string to actual [type]
            $resolvedType = [Type]::GetType($typeString, $false)

            if ($null -eq $resolvedType) {
                Write-Warning "Could not resolve type '$typeString' for property '$property_name'. Defaulting to string."
                $resolvedType = [string]
            }

            # Try casting the value to the original type
            if( ($resolvedType -eq [bool]) -Or ($resolvedType -eq [Boolean]) ) {
                $converted_boolean = if($property_value -eq '0'){ $False }else{ $True }
                $convertedValue = [bool]::Parse($converted_boolean)
            }
            elseif ($resolvedType.IsEnum) {
                $convertedValue = [Enum]::Parse($resolvedType, $property_value)
            }
            elseif ($resolvedType -eq [string[]] -and ($property_value -is [string])) {
                $convertedValue = ,$property_value  # Ensure it's an array
            }
            else {
                $convertedValue = $property_value -as $resolvedType
            }

            Write-Verbose "Restoring '$property_name' as [$($resolvedType.FullName)]: $convertedValue"

            $TaskProperties | Add-Member -MemberType NoteProperty -Name $property_name -Value $convertedValue -Force
        } catch {
            Write-Warning "Failed to restore property '$property_name': $_"
        }
    }

    return $TaskProperties
}


function Add-SchedTasks {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $true, Position = 0)]
        [string]$TaskName
    )

    $registryPath = "HKCU:\Software\arsscriptum\PowerShell.Module.ClientTools\SchedTasks"

    # Ensure the registry path exists
    if (-not (Test-Path $registryPath)) {
        New-Item -Path $registryPath -Force | Out-Null
    }

    # Get all script files (*.ps1) in the specified folder
    $rval = Get-ItemProperty -Path $registryPath -Name "activetasks" -ErrorAction Ignore

    [string[]]$list = @()
    if (!($rval)) {
        $list += "$TaskName"
        Set-ItemProperty -Path $registryPath -Name "activetasks" -Value $list -Type MultiString
    } else {
        [string[]]$list = $rval.activetasks
        $list += "$TaskName"
        Set-ItemProperty -Path $registryPath -Name "activetasks" -Value $list -Type MultiString
    }
}


function Get-SchedTasks {
    [CmdletBinding(SupportsShouldProcess)]
    param()

    $registryPath = "HKCU:\Software\arsscriptum\PowerShell.Module.ClientTools\SchedTasks"
    [string[]]$list = @()
    # Ensure the registry path exists
    if (-not (Test-Path $registryPath)) {
        return $list
    }

    # Get all script files (*.ps1) in the specified folder
    $rval = Get-ItemProperty -Path $registryPath -Name "activetasks" -ErrorAction Ignore

    [string[]]$list = @()
    if (!($rval)) {
        return $list
    } else {
        [string[]]$list = $rval.activetasks
        return $list
    }
    $list
}


function Clear-SchedTasks {
    [CmdletBinding(SupportsShouldProcess)]
    param()

    $registryPath = "HKCU:\Software\arsscriptum\PowerShell.Module.ClientTools\SchedTasks"
    [string[]]$list = @()
    # Ensure the registry path exists
    if (-not (Test-Path $registryPath)) {
        return
    }

    # Get all script files (*.ps1) in the specified folder
    $rval = Get-ItemProperty -Path $registryPath -Name "activetasks" -ErrorAction Ignore


    if (!($rval)) {
        return
    } else {
        Remove-Item -Path $rval.PSPath -Force -Recurse
        Write-Verbose "Deleted registry key: $($rval.PSChildName)"
    }
}

function Remove-SchedTasks {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $true, Position = 0)]
        [string]$TaskName
    )

    $registryPath = "HKCU:\Software\arsscriptum\PowerShell.Module.ClientTools\SchedTasks"

    # Check if registry key exists
    if (-not (Test-Path $registryPath)) {
        Write-Verbose "No scheduled task registry key exists."
        return
    }

    # Retrieve the existing list
    $rval = Get-ItemProperty -Path $registryPath -Name "activetasks" -ErrorAction SilentlyContinue

    if ($null -ne $rval -and $rval.activetasks) {
        [string[]]$list = $rval.activetasks
        # Remove the task (case-insensitive match)
        $newList = $list | Where-Object { $_ -ne $TaskName }

        if ($newList.Count -eq 0) {
            Remove-ItemProperty -Path $registryPath -Name "activetasks" -ErrorAction SilentlyContinue
        } else {
            Set-ItemProperty -Path $registryPath -Name "activetasks" -Value $newList -Type MultiString
        }

        Write-Verbose "Removed task '$TaskName' from scheduled task registry."
    } else {
        Write-Verbose "No active tasks found to remove."
    }
}

function Show-SchedTasksDebugInfo {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $false)]
        [switch]$Json
    )


    try {
        [string[]]$TasksList = Get-SchedTasks
        if (-not $TasksList -or $TasksList.Count -eq 0) {
            Write-Host "⚠ No scheduled tasks found in registry list." -ForegroundColor Yellow
            return
        }

        foreach ($task in $TasksList) {
            try {
                $TaskDetails = Get-ScheduledTaskDetails -TaskName $task
                $Status = Get-ScheduledTaskInfo -TaskName $task -ErrorAction Stop

                Write-Host "`n=========================================" -ForegroundColor DarkGray
                Write-Host "Scheduled Task : $task" -ForegroundColor Cyan
                Write-Host "Path           : $($TaskDetails.TaskPath)"
                Write-Host "User           : $($TaskDetails.Principal.UserId)"
                Write-Host "Created        : $($TaskDetails.General_DateCreated)"
                Write-Host "State          : $($Status.State)"
                Write-Host "Last Run Time  : $($Status.LastRunTime)"
                Write-Host "Last Result    : $($Status.LastTaskResult)"
                Write-Host "Next Run Time  : $($Status.NextRunTime)"
                Write-Host "Execute        : $($TaskDetails.Actions_Execute)"
                Write-Host "Arguments      : $($TaskDetails.Actions_Arguments)"
                Write-Host "Start Boundary : $($TaskDetails.Triggers_StartBoundary)"
                Write-Host "End Boundary   : $($TaskDetails.Triggers_EndBoundary)"
                Write-Host "Enabled        : $($TaskDetails.Triggers_Enabled)"
            } catch {
                Write-Warning "⚠ Failed to get task info for '$task': $_"
            }
        }

    } catch {
        Write-Error "❌ Error during update check: $_"
        return $false
    }
}

function ConvertFrom-CimType {
    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([Type])]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, HelpMessage = "CIM type to convert")]
        [Microsoft.Management.Infrastructure.CimType]$CimType
    )

    process {
        switch ($CimType) {
            'Boolean'        { [bool] }
            'Char16'         { [char] }
            'DateTime'       { [string] } # Can optionally be parsed to [datetime]
            'Instance'       { [Microsoft.Management.Infrastructure.CimInstance] }
            'Real32'         { [single] }
            'Real64'         { [double] }
            'Reference'      { [Microsoft.Management.Infrastructure.CimInstance] }
            'SInt8'          { [sbyte] }
            'UInt8'          { [byte] }
            'SInt16'         { [int16] }
            'UInt16'         { [uint16] }
            'SInt32'         { [int32] }
            'UInt32'         { [uint32] }
            'SInt64'         { [int64] }
            'UInt64'         { [uint64] }
            'String'         { [string] }
            'Object'         { [object] }

            'BooleanArray'   { [bool[]] }
            'Char16Array'    { [char[]] }
            'DateTimeArray'  { [string[]] }
            'InstanceArray'  { [Microsoft.Management.Infrastructure.CimInstance[]] }
            'Real32Array'    { [single[]] }
            'Real64Array'    { [double[]] }
            'ReferenceArray' { [Microsoft.Management.Infrastructure.CimInstance[]] }
            'SInt8Array'     { [sbyte[]] }
            'UInt8Array'     { [byte[]] }
            'SInt16Array'    { [int16[]] }
            'UInt16Array'    { [uint16[]] }
            'SInt32Array'    { [int32[]] }
            'UInt32Array'    { [uint32[]] }
            'SInt64Array'    { [int64[]] }
            'UInt64Array'    { [uint64[]] }
            'StringArray'    { [string[]] }
            'ObjectArray'    { [object[]] }

            default {
                throw "❌ Unsupported CimType: $CimType"
            }
        }
    }
}



function Unregister-AllSchedTasks {
    [CmdletBinding(SupportsShouldProcess)]
    param()


    try {
        [string[]]$TasksList = Get-SchedTasks
        if (-not $TasksList -or $TasksList.Count -eq 0) {
            Write-Host "⚠ No scheduled tasks found in registry list." -ForegroundColor Yellow
            return
        }
        [System.Collections.Arraylist]$DeleteList = [System.Collections.ArrayList]::new()
        foreach ($task in $TasksList) {
            try {
                $TaskPtr = Get-ScheduledTask -TaskName $task -ErrorAction Ignore
                if($TaskPtr -ne $Null){
                    $task_name = $TaskPtr.TaskName
                    $prop = $TaskPtr.CimInstanceProperties.Where({$_.Name -eq 'State'})
                    $propType = $prop.CimType | ConvertFrom-CimType 
                    $CurrentState = $prop.Value -as $propType
                    try{
                      Write-Host "Unregistering ScheduledTask `"$task_name`" (state $CurrentState) " -f DarkYellow -n
                      $TaskPtr | Unregister-ScheduledTask -Confirm:$False -ErrorAction Stop
                      Write-Host "Success!" -f DarkGreen
                      [void]$DeleteList.Add($task_name)
                    }catch{
                        Write-Host "Failed! ($_)" -f DarkRed
                    }
                }
        }

        if($($DeleteList.Count) -gt 0){


        Write-Host "Cleaning up: " -n -f DarkRed

        foreach ($rmtask in $DeleteList) {
            Write-Host "$rmtask " -n -f DarkCyan
            Remove-SchedTasks $rmtask
        }
        Write-Host "`nRemoved $($DeleteList.Count) tasks" -f DarkCyan
    } catch {
        Write-Error "❌ Error during update check: $_"
        return $false
    }
}

function Invoke-EnsureSharedScriptFolder {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $false, Position = 0)]
        [string]$Path = 'C:\ProgramData\arsscriptum\scripts'
    )

    [string]$SharedPath = $Path

    # Create folder if it doesn't exist
    if (-not (Test-Path $SharedPath)) {
        New-Item -Path $SharedPath -ItemType Directory -Force | Out-Null
    }

    # Set access rights to allow all users to read/execute files
    $acl = Get-Acl $SharedPath
    $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule (
        "Users", "ReadAndExecute", "ContainerInherit, ObjectInherit", "None", "Allow"
    )

    if (-not $acl.Access | Where-Object { $_.IdentityReference -eq "Users" -and $_.FileSystemRights -match "ReadAndExecute" }) {
        $acl.SetAccessRule($accessRule)
        Set-Acl -Path $SharedPath -AclObject $acl
    }

    return $SharedPath
}




function Wait-ClientToolsModuleUpdate {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [switch]$Online,
        [Parameter(Mandatory = $false, HelpMessage = "Maximum number of seconds to wait.")]
        [ValidateRange(1, 86400)]
        [int]$TimeoutSeconds = 300,

        [Parameter(Mandatory = $false, HelpMessage = "Check interval in seconds.")]
        [ValidateRange(1, 300)]
        [int]$CheckIntervalSeconds = 1
    )

    $Local = $True
    if ($Online) {
        $Local = $false

    }

    $StartTime = Get-Date
    $TimeoutTime = $StartTime.AddSeconds($TimeoutSeconds)

    try {

        if ($Local) {
            [version]$InitialVersion = Get-ClientToolsModuleVersion
            [version]$LatestVersion = Get-ClientToolsModuleVersion -Latest
            if ($InitialVersion -eq $LatestVersion) {
                Write-Host "🔄 Waiting for version to update from $InitialVersion..." -ForegroundColor Yellow
            } else {

                Write-Host "✅ Already updated: $InitialVersion -> $LatestVersion" -ForegroundColor Green
                return $true
            }
        } else {
            [version]$InitialVersion = Get-ClientToolsModuleVersion -Latest
            [version]$LatestVersion = Get-ClientToolsModuleVersion -Latest
        }

        while ((Get-Date) -lt $TimeoutTime) {
            Start-Sleep -Seconds $CheckIntervalSeconds
            if ($Local) {
                [version]$CurrentVersion = Get-ClientToolsModuleVersion
            } else {
                [version]$CurrentVersion = Get-ClientToolsModuleVersion -Latest
            }
            if ($CurrentVersion -gt $InitialVersion) {
                Write-Host "✅ Module updated: $InitialVersion → $CurrentVersion" -ForegroundColor Green
                return $true
            }

            Write-Host "⏳ Still waiting... Current: $CurrentVersion (Latest: $LatestVersion)" -ForegroundColor DarkGray
        }

        Write-Warning "⏰ Timeout reached. Module version is still $InitialVersion"
        return $false
    }
    catch {
        Write-Error "❌ Error during update check: $_"
        return $false
    }
}


function Show-ModuleInstallPaths {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $true)]
        [string]$ModuleName
    )

    $paths = $env:PSModulePath -split ';'
    $found = @()

    foreach ($base in $paths) {
        if (-not (Test-Path $base)) { continue }

        $matches = Get-ChildItem -Path $base -Directory -Recurse -Force -ErrorAction SilentlyContinue |
        Where-Object { $_.Name -ieq $ModuleName }

        foreach ($match in $matches) {
            Write-Host "Found: $($match.FullName)" -ForegroundColor Green
            Start-Process "explorer.exe" -ArgumentList "`"$($match.FullName)`""
            $found += $match.FullName
        }
    }

    if (-not $found) {
        Write-Warning "No directories found for module '$ModuleName' in PSModulePath."
    }
}


function Write-ProgressHelper {
    [CmdletBinding()]
    param()
    try {
        if ($Script:TotalSteps -eq 0) { return }
        Write-Progress -Activity $Script:ProgressTitle -Status $Script:ProgressMessage -PercentComplete (($Script:StepNumber / $Script:TotalSteps) * 100)
    } catch {
        Write-Host "⌛ StepNumber $Script:StepNumber" -f DarkYellow
        Write-Host "⌛ ScriptSteps $Script:TotalSteps" -f DarkYellow
        $val = (($Script:StepNumber / $Script:TotalSteps) * 100)
        Write-Host "⌛ PercentComplete $val" -f DarkYellow
        Show-ExceptionDetails $_ -ShowStack
    }
}

function Write-ClientToolsHost {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, Position = 0)][Alias('m')]
        [string]$Message
    )
    Write-Host "[PowerShell.Module.ClientTools] " -f DarkRed -n
    Write-Host "$Message" -f DarkYellow
}



function Test-Function { ############### NOEXPORT
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $true, Position = 0)][Alias('n')] [string]$Name,
        [Parameter(Mandatory = $true, Position = 1)][Alias('m')] [string]$Module
    )
    $Res = $True
    try {
        Write-Verbose "Test $Name [$Module]"
        if (-not (Get-Command "$Name" -ErrorAction Ignore)) { throw "missing function $Name, from module $Module" }
    } catch {
        Write-Host "[Missing Dependency] " -n -f DarkRed
        Write-Host "$_" -f DarkYellow
        $Res = $False
    }
    return $Res
}

function Test-Dependencies { ############### NOEXPORT
    [CmdletBinding(SupportsShouldProcess)]
    param()
    $Res = $True
    try {
        $CoreFuncs = @('Set-RegistryValue', 'New-RegistryValue', 'Register-AppCredentials', 'Decrypt-String')
        foreach ($f in $CoreFuncs) {
            if (-not (Test-Function -n "$f" -m "PowerShell.Module.OpenAI")) { $Res = $False; break; }
        }
    } catch {
        Write-Error "$_"
        $Res = $False
    }
    return $Res
}


<#
    .SYNOPSIS
        FROM C-time converter function
    .DESCRIPTION
        Simple function to convert FROM Unix/Ctime into EPOCH / "friendly" time
#>
function ConvertFrom-Ctime {
    [CmdletBinding()]
    param(
        [Parameter(Position = 0, Mandatory = $true, HelpMessage = "ctime")]
        [int64]$Ctime
    )

    [datetime]$epoch = '1970-01-01 00:00:00'
    [datetime]$result = $epoch.AddSeconds($Ctime)
    return $result
}

<#
    .SYNOPSIS
        INTO C-time converter function
    .DESCRIPTION
        Simple function to convert into FROM EPOCH / "friendly" into Unix/Ctime, which the Inventory Service uses.
#>
function ConvertTo-CTime {
    [CmdletBinding()]
    param(
        [Parameter(Position = 0, Mandatory = $true, HelpMessage = "InputEpoch")]
        [datetime]$InputEpoch
    )

    [datetime]$Epoch = '1970-01-01 00:00:00'
    [int64]$Ctime = 0

    $Ctime = (New-TimeSpan -Start $Epoch -End $InputEpoch).TotalSeconds
    return $Ctime
}

function ConvertFrom-UnixTime {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [int64]$UnixTime
    )
    begin {
        $epoch = [datetime]::SpecifyKind('1970-01-01', 'Local')
    }
    process {
        $epoch.AddSeconds($UnixTime)
    }
}

function ConvertTo-UnixTime {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [datetime]$DateTime
    )
    begin {
        $epoch = [datetime]::SpecifyKind('1970-01-01', 'Local')
    }
    process {
        [int64]($DateTime - $epoch).TotalSeconds
    }
}

function Get-UnixTime {
    $Now = Get-Date
    return ConvertTo-UnixTime $Now
}


function Get-DateString ([switch]$Verbose) {

    if ($Verbose) {
        return ((Get-Date).GetDateTimeFormats()[8]).Replace(' ', '_').ToString()
    }

    $curdate = $(get-date -Format "yyyy-MM-dd_\hhh-\mmmm-\sss")
    return $curdate
}


function Get-DateForFileName ([switch]$Minimal) {
    $sd = (Get-Date).GetDateTimeFormats()[14]
    $sd = $sd.Split('.')[0]
    $sd = $sd.Replace(':', '-');
    if ($Minimal) {
        $sd = $sd.Replace('-', '');
    }
    return $sd
}
