#╔════════════════════════════════════════════════════════════════════════════════╗
#║                                                                                ║
#║   ScheduledTaskDetails.ps1                                                     ║
#║   Get Details of Scheduled Tasks                                               ║
#║                                                                                ║
#╟────────────────────────────────────────────────────────────────────────────────╢
#║   Guillaume Plante <codegp@icloud.com>                                         ║
#║   Code licensed under the GNU GPL v3.0. See the LICENSE file for details.      ║
#╚════════════════════════════════════════════════════════════════════════════════╝


function Test-SerializableProperty {
    [CmdletBinding(SupportsShouldProcess)]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0, HelpMessage = "Name of the scheduled task")]
        [string]$PropertyName
    )

    process {
        $ScheduledTaskProperties = @(
            'State'
            'Actions'
            'Author'
            'Date'
            'Description'
            #'Documentation'
            'Principal'
            #'SecurityDescriptor'
            'Settings'
            #'Source'
            'TaskName'
            'TaskPath'
            'Triggers'
            'URI'
            'Version'
            #'PSComputerName'
            #'CimClass'
            #'CimInstanceProperties'
            #'CimSystemProperties'
        )

        if ($ScheduledTaskProperties.Contains($PropertyName)) {
            return $True
        } else {
            return $False
        }
    }

}




function Get-ScheduledTaskDetails {
    [CmdletBinding(DefaultParameterSetName = 'TaskName')]
    [OutputType([pscustomobject])]
    param(
        [Parameter(Mandatory = $true, ParameterSetName = 'TaskName', HelpMessage = 'TaskName')]
        [string]$TaskName,

        [Parameter(Mandatory = $true, ParameterSetName = 'TaskPath', HelpMessage = 'TaskPath')]
        [string]$TaskPath
    )



    $TaskProperties = [pscustomobject]@{}
    $prop = $TaskPtr.CimInstanceProperties.Where({ $_.Name -eq 'Author' }) {
    #foreach ($prop in $AllTaskData.PSObject.Properties) {
    
        $pname = "$($prop.Name)"
        if (Test-SerializableProperty $pname) {
            $value = $prop.Value
            $typeStruct = $prop.CimType | ConvertFrom-CimType 
            $VariableTypeName = $typeStruct.Name
            $VariableTypeFull = $typeStruct.FullName
            $resolvedType = [type]::GetType($VariableTypeFull, $false)
            if ($null -eq $resolvedType) {
                Write-Warning "Could not resolve type '$typeString' for property '$pname'. Defaulting to string."
                $resolvedType = [string]
            }
if (($resolvedType -eq [bool]) -or ($resolvedType -eq [Boolean])) {
                    $converted_boolean = if ($property_value -eq '0') { $False } else { $True }
                    $convertedValue = [bool]::Parse($converted_boolean)
                }
                elseif ($resolvedType.IsEnum) {
                    $convertedValue = [Enum]::Parse($resolvedType, $property_value)
                }
                elseif ($resolvedType -eq [string[]] -and ($property_value -is [string])) {
                    $convertedValue =, $property_value # Ensure it's an array
                }
                else {
                    $convertedValue = $property_value -as $resolvedType
                }

                Write-Verbose "Restoring '$property_name' as [$($resolvedType.FullName)]: $convertedValue"

                $TaskProperties | Add-Member -MemberType NoteProperty -Name $property_name -Value $convertedValue -Force
        }




        Write-Verbose "$VariableName"

    }

    # Retrieve task data based on parameter set
    if ($PSCmdlet.ParameterSetName -eq 'TaskName') {
        $AllTaskData = Get-ScheduledTask -TaskName $TaskName -ErrorAction Stop
        $DetailsTaskData = schtasks /Query /TN $TaskName /V /FO CSV | ConvertFrom-Csv
    }
    else {
        $AllTaskData = Get-ScheduledTask -TaskPath $TaskPath -ErrorAction Stop
        $Name = $AllTaskData.TaskName
        $DetailsTaskData = schtasks /Query /TN $Name /V /FO CSV | ConvertFrom-Csv
    }

    $UserData = $AllTaskData.Principal
    foreach ($prop in $UserData.PSObject.Properties) {
        $pname = "User_{0}" -f $prop.Name.Replace(' ', '-')
        $AllTaskData | Add-Member -NotePropertyName $pname -NotePropertyValue $prop.Value -Force
    }
    $Settings = $AllTaskData.Settings
    foreach ($prop in $Settings.PSObject.Properties) {
        $pname = "Settings_{0}" -f $prop.Name.Replace(' ', '-')
        $AllTaskData | Add-Member -NotePropertyName $pname -NotePropertyValue $prop.Value -Force
    }
    $Triggers = $AllTaskData.Triggers
    $AllTaskData | Add-Member -NotePropertyName "Triggers_StartBoundary" -NotePropertyValue $Triggers.StartBoundary -Force
    $AllTaskData | Add-Member -NotePropertyName "Triggers_EndBoundary" -NotePropertyValue $Triggers.EndBoundary -Force
    $AllTaskData | Add-Member -NotePropertyName "Triggers_Enabled" -NotePropertyValue $Triggers.Enabled -Force
    $AllTaskData | Add-Member -NotePropertyName "Triggers_DaysOfWeek" -NotePropertyValue $Triggers.DaysOfWeek -Force

    $Actions = $AllTaskData.Actions
    $AllTaskData | Add-Member -NotePropertyName "Actions_Execute" -NotePropertyValue $Actions.Execute -Force
    $AllTaskData | Add-Member -NotePropertyName "Actions_Arguments" -NotePropertyValue $Actions.Arguments -Force

    # Merge properties from $DetailsTaskData into $AllTaskData
    foreach ($prop in $DetailsTaskData.PSObject.Properties) {
        $pname = "General_{0}" -f $prop.Name.Replace(' ', '')
        $AllTaskData | Add-Member -NotePropertyName $pname -NotePropertyValue $prop.Value -Force
    }

    return $AllTaskData
}
